\
\ @file adc.fs
\ @brief ADC interrupt
\
\ This file is auto-generated from SVD file.
\ DO NOT EDIT MANUALLY.
\

.include ../common.fs

\
\ @brief VERSION_ID register
\ Address offset: 0x00
\ Reset value: 0x00000030
\

$000000ff constant ADC_VERSION_ID_VERSION_ID                        \ VERSION_ID[7:0]: version of the embedded IP.


\
\ @brief CONF register
\ Address offset: 0x04
\ Reset value: 0x00020002
\

$00000001 constant ADC_CONF_CONT                                    \ CONT: regular sequence runs continuously when ADC mode is enabled: 0: enable the single conversion: when the sequence is over, the conversion stops 1: enable the continuous conversion: when the sequence is over, the sequence starts again until the software sets the CTRL.STOP_OP_MODE bit.
$00000002 constant ADC_CONF_SEQUENCE                                \ SEQUENCE: enable the sequence mode (active by default): 0: sequence mode is disabled, only SEQ0 is selected 1: sequence mode is enabled, conversions from SEQ0 to SEQx with x=SEQ_LEN Note: clearing this bit is equivalent to SEQUENCE=1 and SEQ_LEN=0000. Ideally, this bit can be kept high as redundant with keeping high and setting SEQ_LEN=0000.
$0000003c constant ADC_CONF_SEQ_LEN                                 \ SEQ_LEN[3:0]: number of conversions in a regular sequence: 0000: 1 conversion, starting from SEQ0 0001: 2 conversions, starting from SEQ0 ... 1111: 16 conversions, starting from SEQ0
$00000040 constant ADC_CONF_SMPS_SYNCHRO_ENA                        \ SMPS_SYNCHRO_ENA: synchronize the ADC start conversion with a pulse generated by the SMPS: 0: SMPS synchronization is disabled for all ADC clock frequencies 1: SMPS synchronization is enabled (only when ADC clock is 8 MHz or 16 MHz) Note: SMPS_SYNCHRO_ENA must be 0 when the ADC analog clock is 32 MHz or when PWRC_CR5.NOSMPS = 1.
$00000600 constant ADC_CONF_SAMPLE_RATE_LSB                         \ SAMPLE_RATE_LSB: Sample Rate LSB This field is an extension of SAMPLE_RATE definition in bits 12,11 of CONF register. It impacts the conversion rate of ADC (F_ADC). See SAMPLE_RATE bits for the full description. When this field is set to a value different than 0, SMPS synchronization is not feasible. This value is hidden to the user
$00001800 constant ADC_CONF_SAMPLE_RATE                             \ SAMPLE_RATE[1:0]: conversion rate of ADC (F_ADC): F_ADC = F_ADC_CLK/(16 + 16*SAMPLE_RATE_MSB + 4*SAMPLE_RATE + SAMPLE_RATE_LSB),where F_ADC_CLK is the analog ADC clock frequency. By default F_ADC_CLK is 16MHz frequency.
$00002000 constant ADC_CONF_DMA_DS_ENA                              \ DMA_DS_EN: enable the DMA mode for the Down Sampler data path: 0: DMA mode is disabled 1: DMA mode is enabled
$00008000 constant ADC_CONF_OVR_DS_CFG                              \ OVR_DS_CFG: Down Sampler overrun configuration: 0: the previous data is kept, the new one is lost 1: the previous data is lost, the new one is kept
$00020000 constant ADC_CONF_BIT_INVERT_SN                           \ BIT_INVERT_SN: invert bit to bit the ADC data output (1's complement) when a single negative input is connected to the ADC: 0: no inversion (default) 1: enable the inversion
$00040000 constant ADC_CONF_BIT_INVERT_DIFF                         \ BIT_INVERT_DIFF: invert bit to bit the ADC data output (1's complement) when a differential input is connected to the ADC: 0: no inversion (default) 1: enable the inversion
$00080000 constant ADC_CONF_ADC_CONT_1V2                            \ ADC_CONT_1V2: select the input sampling method: 0: sampling only at conversion start (default) 1: sampling starts at the end of conversion
$00e00000 constant ADC_CONF_SAMPLE_RATE_MSB                         \ SAMPLE_RATE_MSB: Sample Rate MSB This field is an extension of SAMPLE_RATE definition in bits 12,11 of CONF register. It impacts the conversion rate of ADC (F_ADC). See SAMPLE_RATE bits for the full description


\
\ @brief CTRL register
\ Address offset: 0x08
\ Reset value: 0x00000000
\

$00000001 constant ADC_CTRL_ADC_ON_OFF                              \ ADC_ON_OFF: 0: power off the ADC 1: power on the ADC
$00000002 constant ADC_CTRL_START_CONV                              \ START_CONV (1): generate a start pulse to initiate an ADC conversion: 0: no effect 1: start the ADC conversion Note: this bit is set by software and cleared by hardware.
$00000004 constant ADC_CTRL_STOP_OP_MODE                            \ STOP_OP_MODE (1): stop the on-going OP_MODE (ADC mode, Analog audio mode, Full mode): 0: no effect 1: stop on-going ADC mode Note: this bit is set by software and cleared by hardware. When setting the STOP_MODE_OP, the user has to wait around 10 us before to start a new ADC conversion by setting the START_CONV bit.
$00000010 constant ADC_CTRL_TEST_MODE                               \ TEST_MODE: select the functional or the test mode of the ADC: 0: functional mode (one of the four main functional modes is used) 1: test mode (for debug, test, calibration)
$00000020 constant ADC_CTRL_ADC_LDO_ENA                             \ ADC_LDO_ENA: enable the LDO associated to the ADC block: 0: disable the ADC LDO 1: enable the ADC LDO


\
\ @brief SWITCH register
\ Address offset: 0x14
\ Reset value: 0x00000000
\

$00000003 constant ADC_SWITCH_SE_VIN_0                              \ SE_VIN_0[1:0]: input voltage for VINM[0] / VINP[0]-VINM[0] 00: Vinput = 1.2V 01: reserved (not used for this cut) 10: Vinput = 2.4V 11: Vinput = 3.6V
$0000000c constant ADC_SWITCH_SE_VIN_1                              \ SE_VIN_1[1:0]: input voltage for VINM[1] / VINP[1]-VINM[1] 00: Vinput = 1.2V 01: reserved (not used for this cut) 10: Vinput = 2.4V 11: Vinput = 3.6V
$00000030 constant ADC_SWITCH_SE_VIN_2                              \ SE_VIN_2[1:0]: input voltage for VINM[2] / VINP[2]-VINM[2] 00: Vinput = 1.2V 01: reserved (not used for this cut) 10: Vinput = 2.4V 11: Vinput = 3.6V
$000000c0 constant ADC_SWITCH_SE_VIN_3                              \ SE_VIN_3[1:0]: input voltage for VINM[3] / VINP[3]-VINM[3] 00: Vinput = 1.2V 01: reserved (not used for this cut) 10: Vinput = 2.4V 11: Vinput = 3.6V
$00000300 constant ADC_SWITCH_SE_VIN_4                              \ SE_VIN_4[1:0]: input voltage for VINP[0] 00: Vinput = 1.2V 01: reserved (not used for this cut) 10: Vinput = 2.4V 11: Vinput = 3.6V
$00000c00 constant ADC_SWITCH_SE_VIN_5                              \ SE_VIN_5[1:0]: input voltage for VINP[1] 00: Vinput = 1.2V 01: reserved (not used for this cut) 10: Vinput = 2.4V 11: Vinput = 3.6V
$00003000 constant ADC_SWITCH_SE_VIN_6                              \ SE_VIN_6[1:0]: input voltage for VINP[2] 00: Vinput = 1.2V 01: reserved (not used for this cut) 10: Vinput = 2.4V 11: Vinput = 3.6V
$0000c000 constant ADC_SWITCH_SE_VIN_7                              \ SE_VIN_7[1:0]: input voltage for VINP[3] 00: Vinput = 1.2V 01: reserved (not used for this cut) 10: Vinput = 2.4V 11: Vinput = 3.6V


\
\ @brief DS_CONF register
\ Address offset: 0x1C
\ Reset value: 0x00000000
\

$00000007 constant ADC_DS_CONF_DS_RATIO                             \ DS_RATIO[2:0]: program the Down Sampler ratio (N factor) 000: ratio = 1, no down sampling (default) 001: ratio = 2 010: ratio = 4 011: ratio = 8 100: ratio = 16 101: ratio = 32 110: ratio = 64 111: ratio = 128
$00000038 constant ADC_DS_CONF_DS_WIDTH                             \ DS_WIDTH[2:0]: program the Down Sampler width of data output (DSDTATA) 000: DS_DATA output on 12-bit (default) 001: DS_DATA output on 13-bit 010: DS_DATA output on 14-bit 011: DS_DATA output on 15-bit 100: DS_DATA output on 16-bit 1xx: reserved


\
\ @brief SEQ_1 register
\ Address offset: 0x20
\ Reset value: 0x00000000
\

$0000000f constant ADC_SEQ_1_SEQ0                                   \ SEQ0[3:0]: channel number code for first conversion of the sequence 0000: VINM[0] to ADC single negative input 0001: VINM[1] to ADC single negative input 0010: VINM[2] to ADC single negative input 0011: VINM[3] to ADC single negative input 0100: VINP[0] to ADC single positive input 0101: VINP[1] to ADC single positive input 0110: VINP[2] to ADC single positive input 0111: VINP[3] to ADC single positive input 1000: VINP[0]-VINM[0] to ADC differential input 1001: VINP[1]-VINM[1] to ADC differential input 1010: VINP[2]-VINM[2] to ADC differential input 1011: VINP[3]-VINM[3] to ADC differential input 1100: VBAT Battery level detector 1101: Temperature sensor 111x: reserved
$000000f0 constant ADC_SEQ_1_SEQ1                                   \ SEQ1[3:0]: channel number code for second conversion of the sequence. See SEQ0 for code detail.
$00000f00 constant ADC_SEQ_1_SEQ2                                   \ SEQ2[3:0]: channel number code for 3rd conversion of the sequence. See SEQ0 for code detail.
$0000f000 constant ADC_SEQ_1_SEQ3                                   \ SEQ3[3:0]: channel number code for 4th conversion of the sequence. See SEQ0 for code detail.
$000f0000 constant ADC_SEQ_1_SEQ4                                   \ SEQ4[3:0]: channel number code for 5th conversion of the sequence. See SEQ0 for code detail.
$00f00000 constant ADC_SEQ_1_SEQ5                                   \ SEQ5[3:0]: channel number code for 6th conversion of the sequence. See SEQ0 for code detail.
$0f000000 constant ADC_SEQ_1_SEQ6                                   \ SEQ6[3:0]: channel number code for 7th conversion of the sequence. See SEQ0 for code detail.
$f0000000 constant ADC_SEQ_1_SEQ7                                   \ SEQ7[3:0]: channel number code for 8th conversion of the sequence. See SEQ0 for code detail.


\
\ @brief SEQ_2 register
\ Address offset: 0x24
\ Reset value: 0x00000000
\

$0000000f constant ADC_SEQ_2_SEQ8                                   \ SEQ8[3:0]: channel number code for 9th conversion of the sequence 0000: VINM[0] to ADC single negative input 0001: VINM[1] to ADC single negative input 0010: VINM[2] to ADC single negative input 0011: VINM[3] to ADC single negative input 0100: VINP[0] to ADC single positive input 0101: VINP[1] to ADC single positive input 0110: VINP[2] to ADC single positive input 0111: VINP[3] to ADC single positive input 1000: VINP[0]-VINM[0] to ADC differential input 1001: VINP[1]-VINM[1] to ADC differential input 1010: VINP[2]-VINM[2] to ADC differential input 1011: VINP[3]-VINM[3] to ADC differential input 1100: VBAT Battery level detector 1101: Temperature sensor 111x: reserved
$000000f0 constant ADC_SEQ_2_SEQ9                                   \ SEQ9[3:0]: channel number code for 10th conversion of the sequence. See SEQ0 for code detail.
$00000f00 constant ADC_SEQ_2_SEQ10                                  \ SEQ10[3:0]: channel number code for 11th conversion of the sequence. See SEQ0 for code detail.
$0000f000 constant ADC_SEQ_2_SEQ11                                  \ SEQ11[3:0]: channel number code for 12th conversion of the sequence. See SEQ0 for code detail.
$000f0000 constant ADC_SEQ_2_SEQ12                                  \ SEQ12[3:0]: channel number code for 13th conversion of the sequence. See SEQ0 for code detail.
$00f00000 constant ADC_SEQ_2_SEQ13                                  \ SEQ13[3:0]: channel number code for 14th conversion of the sequence. See SEQ0 for code detail.
$0f000000 constant ADC_SEQ_2_SEQ14                                  \ SEQ14[3:0]: channel number code for 15th conversion of the sequence. See SEQ0 for code detail.
$f0000000 constant ADC_SEQ_2_SEQ15                                  \ SEQ15[3:0]: channel number code for 16th conversion of the sequence. See SEQ0 for code detail.


\
\ @brief COMP_1 register
\ Address offset: 0x28
\ Reset value: 0x00000555
\

$00000fff constant ADC_COMP_1_GAIN1                                 \ GAIN1[11:0]: first calibration point: gain AUXADC_GAIN_1V2[11:0]
$000ff000 constant ADC_COMP_1_OFFSET1                               \ OFFSET1[7:0]: first calibration point: offset compensation[7:0] with sign


\
\ @brief COMP_2 register
\ Address offset: 0x2C
\ Reset value: 0x00000555
\

$00000fff constant ADC_COMP_2_GAIN2                                 \ GAIN2[11:0]: second calibration point: gain AUXADC_GAIN_1V2[11:0]
$000ff000 constant ADC_COMP_2_OFFSET2                               \ OFFSET2[7:0]: second calibration point: offset compensation[7:0] with sign


\
\ @brief COMP_3 register
\ Address offset: 0x30
\ Reset value: 0x00000555
\

$00000fff constant ADC_COMP_3_GAIN3                                 \ GAIN3[11:0]: third calibration point: gain AUXADC_GAIN_1V2[11:0]
$000ff000 constant ADC_COMP_3_OFFSET3                               \ OFFSET3[7:0]: third calibration point: offset compensation[7:0] with sign


\
\ @brief COMP_4 register
\ Address offset: 0x34
\ Reset value: 0x00000555
\

$00000fff constant ADC_COMP_4_GAIN4                                 \ GAIN4[11:0]: fourth calibration point: gain AUXADC_GAIN_1V2[11:0]
$000ff000 constant ADC_COMP_4_OFFSET4                               \ OFFSET4[7:0]: fourth calibration point: offset compensation[7:0] with sign


\
\ @brief COMP_SEL register
\ Address offset: 0x38
\ Reset value: 0x00000000
\

$00000003 constant ADC_COMP_SEL_OFFSET_GAIN0                        \ OFFSET_GAIN0[1:0]: gain / offset used in ADC single negative mode with Vinput range = 1.2V: 00: OFFSET1 and GAIN1 from COMP_1 01: OFFSET2 and GAIN2 from COMP_2 10: OFFSET3 and GAIN3 from COMP_3 11: OFFSET4 and GAIN4 from COMP_4
$0000000c constant ADC_COMP_SEL_OFFSET_GAIN1                        \ OFFSET_GAIN1[1:0]: gain / offset used in ADC single positive mode with Vinput range = 1.2V: 00: OFFSET1 and GAIN1 from COMP_1 01: OFFSET2 and GAIN2 from COMP_2 10: OFFSET3 and GAIN3 from COMP_3 11: OFFSET4 and GAIN4 from COMP_4
$00000030 constant ADC_COMP_SEL_OFFSET_GAIN2                        \ OFFSET_GAIN2[1:0]: gain / offset used in ADC differential mode with Vinput range = 1.2V: 00: OFFSET1 and GAIN1 from COMP_1 01: OFFSET2 and GAIN2 from COMP_2 10: OFFSET3 and GAIN3 from COMP_3 11: OFFSET4 and GAIN4 from COMP_4
$000000c0 constant ADC_COMP_SEL_OFFSET_GAIN3                        \ OFFSET_GAIN3[1:0]: gain / offset used in ADC single negative mode with Vinput range = 2.4V: 00: OFFSET1 and GAIN1 from COMP_1 01: OFFSET2 and GAIN2 from COMP_2 10: OFFSET3 and GAIN3 from COMP_3 11: OFFSET4 and GAIN4 from COMP_4
$00000300 constant ADC_COMP_SEL_OFFSET_GAIN4                        \ OFFSET_GAIN4[1:0]: gain / offset used in ADC single positive mode with Vinput range = 2.4V: 00: OFFSET1 and GAIN1 from COMP_1 01: OFFSET2 and GAIN2 from COMP_2 10: OFFSET3 and GAIN3 from COMP_3 11: OFFSET4 and GAIN4 from COMP_4
$00000c00 constant ADC_COMP_SEL_OFFSET_GAIN5                        \ OFFSET_GAIN5[1:0]: gain / offset used in ADC differential mode with Vinput range = 2.4V: 00: OFFSET1 and GAIN1 from COMP_1 01: OFFSET2 and GAIN2 from COMP_2 10: OFFSET3 and GAIN3 from COMP_3 11: OFFSET4 and GAIN4 from COMP_4
$00003000 constant ADC_COMP_SEL_OFFSET_GAIN6                        \ OFFSET_GAIN6[1:0]: gain / offset used in ADC single negative mode with Vinput range = 3.6V: 00: OFFSET1 and GAIN1 from COMP_1 01: OFFSET2 and GAIN2 from COMP_2 10: OFFSET3 and GAIN3 from COMP_3 11: OFFSET4 and GAIN4 from COMP_4
$0000c000 constant ADC_COMP_SEL_OFFSET_GAIN7                        \ OFFSET_GAIN7[1:0]: gain / offset used in ADC single positive mode with Vinput range = 3.6V: 00: OFFSET1 and GAIN1 from COMP_1 01: OFFSET2 and GAIN2 from COMP_2 10: OFFSET3 and GAIN3 from COMP_3 11: OFFSET4 and GAIN4 from COMP_4
$00030000 constant ADC_COMP_SEL_OFFSET_GAIN8                        \ OFFSET_GAIN8[1:0]: gain / offset used in ADC differential mode with Vinput range = 3.6V: 00: OFFSET1 and GAIN1 from COMP_1 01: OFFSET2 and GAIN2 from COMP_2 10: OFFSET3 and GAIN3 from COMP_3 11: OFFSET4 and GAIN4 from COMP_4


\
\ @brief WD_TH register
\ Address offset: 0x3C
\ Reset value: 0x0FFF0000
\

$00000fff constant ADC_WD_TH_WD_LT                                  \ WD_LT[11:0]: analog watchdog low level threshold.
$0fff0000 constant ADC_WD_TH_WD_HT                                  \ WD_HT[11:0]: analog watchdog high level threshold.


\
\ @brief WD_CONF register
\ Address offset: 0x40
\ Reset value: 0x00000000
\

$0000ffff constant ADC_WD_CONF_AWD_CHX                              \ AWD_CHX[15:0]: analog watchdog channel selection to define which input channel(s) need to be guarded by the watchdog. Bit0: VINM[0] to ADC negative input Bit1: VINM[1] to ADC negative input Bit2: VINM[2] to ADC negative input Bit3: VINM[3] to ADC negative input Bit4: Not used Bit5: VBAT to ADC negative input Bit6: GND to ADC negative input Bit7: VDDA to ADC negative input Bit8: VINP[0] to ADC positive input Bit9: VINP[1] to ADC positive input Bit10: VINP[2] to ADC positive input Bit11: VINP[3] to ADC positive input Bit12: Not used Bit13: TEMP to ADC positive input Bit14: GND to ADC positive input Bit15: VDDA to ADC positive input


\
\ @brief DS_DATAOUT register
\ Address offset: 0x44
\ Reset value: 0x00000000
\

$0000ffff constant ADC_DS_DATAOUT_DS_DATA                           \ DS_DATA[15:0]: contain the converted data at the output of the Down Sampler.


\
\ @brief IRQ_STATUS register
\ Address offset: 0x4C
\ Reset value: 0x00000000
\

$00000001 constant ADC_IRQ_STATUS_EOC_IRQ                           \ EOC_IRQ (Used in test mode only): set when the ADC conversion is completed. When read, provide the status of the interrupt: 0: ADC conversion is not completed 1: ADC conversion is completed Writing this bit clears the status of the interrupt: 0: no effect 1: clear the interrupt
$00000002 constant ADC_IRQ_STATUS_EODS_IRQ                          \ EODS_IRQ: set when the Down Sampler conversion is completed. When read, provide the status of the interrupt: 0: Down Sampler conversion is not completed 1: Down Sampler conversion is completed Writing this bit clears the status of the interrupt: 0: no effect 1: clear the interrupt
$00000008 constant ADC_IRQ_STATUS_EOS_IRQ                           \ EOS_IRQ: set when a sequence of conversion is completed. When read, provide the status of the interrupt: 0: sequence of conversion is not completed 1: sequence of conversion is completed Writing this bit clears the status of the interrupt: 0: no effect 1: clear the interrupt
$00000010 constant ADC_IRQ_STATUS_AWD_IRQ                           \ AWD_IRQ: set when an analog watchdog event occurs. When read, provide the status of the interrupt: 0: no analog watchdog event occurred 1: analog watchdog event has occurred Writing this bit clears the status of the interrupt: 0: no effect 1: clear the interrupt
$00000020 constant ADC_IRQ_STATUS_OVR_DS_IRQ                        \ OVR_DS_IRQ: set to indicate a Down Sampler overrun (at least one data is lost) When read, provide the status of the interrupt: 0: no overrun occurred 1: overrun occurred Writing this bit clears the status of the interrupt: 0: no effect 1: clear the interrupt


\
\ @brief IRQ_ENABLE register
\ Address offset: 0x50
\ Reset value: 0x00000000
\

$00000001 constant ADC_IRQ_ENABLE_EOC_IRQ                           \ EOC_IRQ (Used in test mode only): set when the ADC conversion is completed. When read, provide the status of the interrupt: 0: ADC conversion is not completed 1: ADC conversion is completed Writing this bit clears the status of the interrupt: 0: no effect 1: clear the interrupt
$00000002 constant ADC_IRQ_ENABLE_EODS_IRQ                          \ EODS_IRQ: set when the Down Sampler conversion is completed. When read, provide the status of the interrupt: 0: Down Sampler conversion is not completed 1: Down Sampler conversion is completed Writing this bit clears the status of the interrupt: 0: no effect 1: clear the interrupt
$00000008 constant ADC_IRQ_ENABLE_EOS_IRQ                           \ EOS_IRQ: set when a sequence of conversion is completed. When read, provide the status of the interrupt: 0: sequence of conversion is not completed 1: sequence of conversion is completed Writing this bit clears the status of the interrupt: 0: no effect 1: clear the interrupt
$00000010 constant ADC_IRQ_ENABLE_AWD_IRQ                           \ AWD_IRQ: set when an analog watchdog event occurs. When read, provide the status of the interrupt: 0: no analog watchdog event occurred 1: analog watchdog event has occurred Writing this bit clears the status of the interrupt: 0: no effect 1: clear the interrupt
$00000020 constant ADC_IRQ_ENABLE_OVR_DS_IRQ                        \ OVR_DS_IRQ: set to indicate a Down Sampler overrun (at least one data is lost) When read, provide the status of the interrupt: 0: no overrun occurred 1: overrun occurred Writing this bit clears the status of the interrupt: 0: no effect 1: clear the interrupt


\
\ @brief ADC interrupt
\
$41006000 constant ADC_VERSION_ID  \ offset: 0x00 : VERSION_ID register
$41006004 constant ADC_CONF       \ offset: 0x04 : CONF register
$41006008 constant ADC_CTRL       \ offset: 0x08 : CTRL register
$41006014 constant ADC_SWITCH     \ offset: 0x14 : SWITCH register
$4100601c constant ADC_DS_CONF    \ offset: 0x1C : DS_CONF register
$41006020 constant ADC_SEQ_1      \ offset: 0x20 : SEQ_1 register
$41006024 constant ADC_SEQ_2      \ offset: 0x24 : SEQ_2 register
$41006028 constant ADC_COMP_1     \ offset: 0x28 : COMP_1 register
$4100602c constant ADC_COMP_2     \ offset: 0x2C : COMP_2 register
$41006030 constant ADC_COMP_3     \ offset: 0x30 : COMP_3 register
$41006034 constant ADC_COMP_4     \ offset: 0x34 : COMP_4 register
$41006038 constant ADC_COMP_SEL   \ offset: 0x38 : COMP_SEL register
$4100603c constant ADC_WD_TH      \ offset: 0x3C : WD_TH register
$41006040 constant ADC_WD_CONF    \ offset: 0x40 : WD_CONF register
$41006044 constant ADC_DS_DATAOUT  \ offset: 0x44 : DS_DATAOUT register
$4100604c constant ADC_IRQ_STATUS  \ offset: 0x4C : IRQ_STATUS register
$41006050 constant ADC_IRQ_ENABLE  \ offset: 0x50 : IRQ_ENABLE register

