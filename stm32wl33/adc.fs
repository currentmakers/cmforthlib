\
\ @file adc.fs
\ @brief ADC address block description
\
\ This file is auto-generated from SVD file.
\ DO NOT EDIT MANUALLY.
\

[ifndef] ADC_DEF

  [ifdef] ADC_VERSION_ID_DEF
    \
    \ @brief VERSION_ID register
    \ Address offset: 0x00
    \ Reset value: 0x00000021
    \
    $00 constant ADC_VERSION_ID                 \ [0x00 : 8] VERSION_ID[7:0]: version of the embedded IP.
  [then]


  [ifdef] ADC_CONF_DEF
    \
    \ @brief CONF register
    \ Address offset: 0x04
    \ Reset value: 0x00020002
    \
    $00 constant ADC_CONT                       \ [0x00] CONT: regular sequence runs continuously when ADC mode is enabled: 0: enable the single conversion: when the sequence is over, the conversion stops 1: enable the continuous conversion: when the sequence is over, the sequence starts again until the software sets the CTRL.STOP_OP_MODE bit.
    $01 constant ADC_SEQUENCE                   \ [0x01] SEQUENCE: enable the sequence mode (active by default): 0: sequence mode is disabled, only SEQ0 is selected 1: sequence mode is enabled, conversions from SEQ0 to SEQx with x=SEQ_LEN Note: clearing this bit is equivalent to SEQUENCE=1 and SEQ_LEN=0000. Ideally, this bit can be kept high as redundant with keeping high and setting SEQ_LEN=0000.
    $02 constant ADC_SEQ_LEN                    \ [0x02 : 4] SEQ_LEN[3:0]: number of conversions in a regular sequence: 0000: 1 conversion, starting from SEQ0 0001: 2 conversions, starting from SEQ0 ... 1111: 16 conversions, starting from SEQ0
    $06 constant ADC_SMPS_SYNCHRO_ENA           \ [0x06] SMPS_SYNCHRO_ENA: synchronize the ADC start conversion with a pulse generated by the SMPS: 0: SMPS synchronization is disabled for all ADC clock frequencies 1: SMPS synchronization is enabled (only when ADC clock is 8 MHz or 16 MHz) Note: SMPS_SYNCHRO_ENA must be 0 when the ADC analog clock is 32 MHz or when PWRC_CR5.NOSMPS = 1.
    $09 constant ADC_SAMPLE_RATE_LSB            \ [0x09 : 2] SAMPLE_RATE_LSB: Sample Rate LSB This field is an extension of SAMPLE_RATE definition in bits 12,11 of CONF register. It impacts the conversion rate of ADC (F_ADC). See SAMPLE_RATE bits for the full description. When this field is set to a value different than 0, SMPS synchronization is not feasible. This value is hidden to the user
    $0b constant ADC_SAMPLE_RATE                \ [0x0b : 2] SAMPLE_RATE[1:0]: conversion rate of ADC (F_ADC): F_ADC = F_ADC_CLK/(16 + 16*SAMPLE_RATE_MSB + 4*SAMPLE_RATE + SAMPLE_RATE_LSB),where F_ADC_CLK is the analog ADC clock frequency. By default F_ADC_CLK is 16MHz frequency.
    $0d constant ADC_DMA_DS_ENA                 \ [0x0d] DMA_DS_EN: enable the DMA mode for the Down Sampler data path: 0: DMA mode is disabled 1: DMA mode is enabled
    $0f constant ADC_OVR_DS_CFG                 \ [0x0f] OVR_DS_CFG: Down Sampler overrun configuration: 0: the previous data is kept, the new one is lost 1: the previous data is lost, the new one is kept
    $11 constant ADC_BIT_INVERT_SN              \ [0x11] BIT_INVERT_SN: invert bit to bit the ADC data output (1's complement) when a single negative input is connected to the ADC: 0: no inversion (default) 1: enable the inversion
    $12 constant ADC_BIT_INVERT_DIFF            \ [0x12] BIT_INVERT_DIFF: invert bit to bit the ADC data output (1's complement) when a differential input is connected to the ADC: 0: no inversion (default) 1: enable the inversion
    $13 constant ADC_ADC_CONT_1V2               \ [0x13] ADC_CONT_1V2: select the input sampling method: 0: sampling only at conversion start (default) 1: sampling starts at the end of conversion
    $15 constant ADC_SAMPLE_RATE_MSB            \ [0x15 : 3] SAMPLE_RATE_MSB: Sample Rate MSB This field is an extension of SAMPLE_RATE definition in bits 12,11 of CONF register. It impacts the conversion rate of ADC (F_ADC). See SAMPLE_RATE bits for the full description
  [then]


  [ifdef] ADC_CTRL_DEF
    \
    \ @brief CTRL register
    \ Address offset: 0x08
    \ Reset value: 0x00000000
    \
    $00 constant ADC_ADC_ON_OFF                 \ [0x00] ADC_ON_OFF: 0: power off the ADC 1: power on the ADC
    $01 constant ADC_START_CONV                 \ [0x01] START_CONV (1): generate a start pulse to initiate an ADC conversion: 0: no effect 1: start the ADC conversion Note: this bit is set by software and cleared by hardware.
    $02 constant ADC_STOP_OP_MODE               \ [0x02] STOP_OP_MODE (1): stop the on-going OP_MODE (ADC mode, Analog audio mode, Full mode): 0: no effect 1: stop on-going ADC mode Note: this bit is set by software and cleared by hardware. When setting the STOP_MODE_OP, the user has to wait around 10 us before to start a new ADC conversion by setting the START_CONV bit.
    $04 constant ADC_TEST_MODE                  \ [0x04] TEST_MODE: select the functional or the test mode of the ADC: 0: functional mode (one of the four main functional modes is used) 1: test mode (for debug, test, calibration)
  [then]


  [ifdef] ADC_SWITCH_DEF
    \
    \ @brief SWITCH register
    \ Address offset: 0x14
    \ Reset value: 0x00000000
    \
    $00 constant ADC_SE_VIN_0                   \ [0x00 : 2] SE_VIN_0[1:0]: input voltage for VINM[0] / VINP[0]-VINM[0] 00: Vinput = 1.2V 01: reserved (not used for this cut) 10: Vinput = 2.4V 11: Vinput = 3.6V
    $02 constant ADC_SE_VIN_1                   \ [0x02 : 2] SE_VIN_1[1:0]: input voltage for VINM[1] / VINP[1]-VINM[1] 00: Vinput = 1.2V 01: reserved (not used for this cut) 10: Vinput = 2.4V 11: Vinput = 3.6V
    $04 constant ADC_SE_VIN_2                   \ [0x04 : 2] SE_VIN_2[1:0]: input voltage for VINM[2] / VINP[2]-VINM[2] 00: Vinput = 1.2V 01: reserved (not used for this cut) 10: Vinput = 2.4V 11: Vinput = 3.6V
    $06 constant ADC_SE_VIN_3                   \ [0x06 : 2] SE_VIN_3[1:0]: input voltage for VINM[3] / VINP[3]-VINM[3] 00: Vinput = 1.2V 01: reserved (not used for this cut) 10: Vinput = 2.4V 11: Vinput = 3.6V
    $08 constant ADC_SE_VIN_4                   \ [0x08 : 2] SE_VIN_4[1:0]: input voltage for VINP[0] 00: Vinput = 1.2V 01: reserved (not used for this cut) 10: Vinput = 2.4V 11: Vinput = 3.6V
    $0a constant ADC_SE_VIN_5                   \ [0x0a : 2] SE_VIN_5[1:0]: input voltage for VINP[1] 00: Vinput = 1.2V 01: reserved (not used for this cut) 10: Vinput = 2.4V 11: Vinput = 3.6V
    $0c constant ADC_SE_VIN_6                   \ [0x0c : 2] SE_VIN_6[1:0]: input voltage for VINP[2] 00: Vinput = 1.2V 01: reserved (not used for this cut) 10: Vinput = 2.4V 11: Vinput = 3.6V
    $0e constant ADC_SE_VIN_7                   \ [0x0e : 2] SE_VIN_7[1:0]: input voltage for VINP[3] 00: Vinput = 1.2V 01: reserved (not used for this cut) 10: Vinput = 2.4V 11: Vinput = 3.6V
  [then]


  [ifdef] ADC_DS_CONF_DEF
    \
    \ @brief DS_CONF register
    \ Address offset: 0x1C
    \ Reset value: 0x00000000
    \
    $00 constant ADC_DS_RATIO                   \ [0x00 : 3] DS_RATIO[2:0]: program the Down Sampler ratio (N factor) 000: ratio = 1, no down sampling (default) 001: ratio = 2 010: ratio = 4 011: ratio = 8 100: ratio = 16 101: ratio = 32 110: ratio = 64 111: ratio = 128
    $03 constant ADC_DS_WIDTH                   \ [0x03 : 3] DS_WIDTH[2:0]: program the Down Sampler width of data output (DSDTATA) 000: DS_DATA output on 12-bit (default) 001: DS_DATA output on 13-bit 010: DS_DATA output on 14-bit 011: DS_DATA output on 15-bit 100: DS_DATA output on 16-bit 1xx: reserved
  [then]


  [ifdef] ADC_SEQ_1_DEF
    \
    \ @brief SEQ_1 register
    \ Address offset: 0x20
    \ Reset value: 0x00000000
    \
    $00 constant ADC_SEQ0                       \ [0x00 : 4] SEQ0[3:0]: channel number code for first conversion of the sequence 0000: VINM[0] to ADC single negative input 0001: VINM[1] to ADC single negative input 0010: VINM[2] to ADC single negative input 0011: VINM[3] to ADC single negative input 0100: VINP[0] to ADC single positive input 0101: VINP[1] to ADC single positive input 0110: VINP[2] to ADC single positive input 0111: VINP[3] to ADC single positive input 1000: VINP[0]-VINM[0] to ADC differential input 1001: VINP[1]-VINM[1] to ADC differential input 1010: VINP[2]-VINM[2] to ADC differential input 1011: VINP[3]-VINM[3] to ADC differential input 1100: VBAT - Battery level detector 1101: Temperature sensor 111x: reserved
    $04 constant ADC_SEQ1                       \ [0x04 : 4] SEQ1[3:0]: channel number code for second conversion of the sequence. See SEQ0 for code detail.
    $08 constant ADC_SEQ2                       \ [0x08 : 4] SEQ2[3:0]: channel number code for 3rd conversion of the sequence. See SEQ0 for code detail.
    $0c constant ADC_SEQ3                       \ [0x0c : 4] SEQ3[3:0]: channel number code for 4th conversion of the sequence. See SEQ0 for code detail.
    $10 constant ADC_SEQ4                       \ [0x10 : 4] SEQ4[3:0]: channel number code for 5th conversion of the sequence. See SEQ0 for code detail.
    $14 constant ADC_SEQ5                       \ [0x14 : 4] SEQ5[3:0]: channel number code for 6th conversion of the sequence. See SEQ0 for code detail.
    $18 constant ADC_SEQ6                       \ [0x18 : 4] SEQ6[3:0]: channel number code for 7th conversion of the sequence. See SEQ0 for code detail.
    $1c constant ADC_SEQ7                       \ [0x1c : 4] SEQ7[3:0]: channel number code for 8th conversion of the sequence. See SEQ0 for code detail.
  [then]


  [ifdef] ADC_SEQ_2_DEF
    \
    \ @brief SEQ_2 register
    \ Address offset: 0x24
    \ Reset value: 0x00000000
    \
    $00 constant ADC_SEQ8                       \ [0x00 : 4] SEQ8[3:0]: channel number code for 9th conversion of the sequence 0000: VINM[0] to ADC single negative input 0001: VINM[1] to ADC single negative input 0010: VINM[2] to ADC single negative input 0011: VINM[3] to ADC single negative input 0100: VINP[0] to ADC single positive input 0101: VINP[1] to ADC single positive input 0110: VINP[2] to ADC single positive input 0111: VINP[3] to ADC single positive input 1000: VINP[0]-VINM[0] to ADC differential input 1001: VINP[1]-VINM[1] to ADC differential input 1010: VINP[2]-VINM[2] to ADC differential input 1011: VINP[3]-VINM[3] to ADC differential input 1100: VBAT - Battery level detector 1101: Temperature sensor 111x: reserved
    $04 constant ADC_SEQ9                       \ [0x04 : 4] SEQ9[3:0]: channel number code for 10th conversion of the sequence. See SEQ0 for code detail.
    $08 constant ADC_SEQ10                      \ [0x08 : 4] SEQ10[3:0]: channel number code for 11th conversion of the sequence. See SEQ0 for code detail.
    $0c constant ADC_SEQ11                      \ [0x0c : 4] SEQ11[3:0]: channel number code for 12th conversion of the sequence. See SEQ0 for code detail.
    $10 constant ADC_SEQ12                      \ [0x10 : 4] SEQ12[3:0]: channel number code for 13th conversion of the sequence. See SEQ0 for code detail.
    $14 constant ADC_SEQ13                      \ [0x14 : 4] SEQ13[3:0]: channel number code for 14th conversion of the sequence. See SEQ0 for code detail.
    $18 constant ADC_SEQ14                      \ [0x18 : 4] SEQ14[3:0]: channel number code for 15th conversion of the sequence. See SEQ0 for code detail.
    $1c constant ADC_SEQ15                      \ [0x1c : 4] SEQ15[3:0]: channel number code for 16th conversion of the sequence. See SEQ0 for code detail.
  [then]


  [ifdef] ADC_COMP_1_DEF
    \
    \ @brief COMP_1 register
    \ Address offset: 0x28
    \ Reset value: 0x00000555
    \
    $00 constant ADC_GAIN1                      \ [0x00 : 12] GAIN1[11:0]: first calibration point: gain AUXADC_GAIN_1V2[11:0]
    $0c constant ADC_OFFSET1                    \ [0x0c : 8] OFFSET1[7:0]: first calibration point
  [then]


  [ifdef] ADC_COMP_2_DEF
    \
    \ @brief COMP_2 register
    \ Address offset: 0x2C
    \ Reset value: 0x00000555
    \
    $00 constant ADC_GAIN2                      \ [0x00 : 12] GAIN2[11:0]: second calibration point: gain AUXADC_GAIN_1V2[11:0]
    $0c constant ADC_OFFSET2                    \ [0x0c : 8] OFFSET2[7:0]: second calibration point
  [then]


  [ifdef] ADC_COMP_3_DEF
    \
    \ @brief COMP_3 register
    \ Address offset: 0x30
    \ Reset value: 0x00000555
    \
    $00 constant ADC_GAIN3                      \ [0x00 : 12] GAIN3[11:0]: third calibration point: gain AUXADC_GAIN_1V2[11:0]
    $0c constant ADC_OFFSET3                    \ [0x0c : 8] OFFSET3[7:0]: third calibration point
  [then]


  [ifdef] ADC_COMP_4_DEF
    \
    \ @brief COMP_4 register
    \ Address offset: 0x34
    \ Reset value: 0x00000555
    \
    $00 constant ADC_GAIN4                      \ [0x00 : 12] GAIN4[11:0]: fourth calibration point: gain AUXADC_GAIN_1V2[11:0]
    $0c constant ADC_OFFSET4                    \ [0x0c : 8] OFFSET4[7:0]: fourth calibration point
  [then]


  [ifdef] ADC_COMP_SEL_DEF
    \
    \ @brief COMP_SEL register
    \ Address offset: 0x38
    \ Reset value: 0x00000000
    \
    $00 constant ADC_OFFSET_GAIN0               \ [0x00 : 2] OFFSET_GAIN0[1:0]: gain / offset used in ADC single negative mode with Vinput range = 1.2V: 00: OFFSET1 and GAIN1 from COMP_1 01: OFFSET2 and GAIN2 from COMP_2 10: OFFSET3 and GAIN3 from COMP_3 11: OFFSET4 and GAIN4 from COMP_4
    $02 constant ADC_OFFSET_GAIN1               \ [0x02 : 2] OFFSET_GAIN1[1:0]: gain / offset used in ADC single positive mode with Vinput range = 1.2V. This field also selects the gain/offset for Temperature Sensor input:: 00: OFFSET1 and GAIN1 from COMP_1 01: OFFSET2 and GAIN2 from COMP_2 10: OFFSET3 and GAIN3 from COMP_3 11: OFFSET4 and GAIN4 from COMP_4
    $04 constant ADC_OFFSET_GAIN2               \ [0x04 : 2] OFFSET_GAIN2[1:0]: gain / offset used in ADC differential mode with Vinput range = 1.2V: 00: OFFSET1 and GAIN1 from COMP_1 01: OFFSET2 and GAIN2 from COMP_2 10: OFFSET3 and GAIN3 from COMP_3 11: OFFSET4 and GAIN4 from COMP_4
    $06 constant ADC_OFFSET_GAIN3               \ [0x06 : 2] OFFSET_GAIN3[1:0]: gain / offset used in ADC single negative mode with Vinput range = 2.4V: 00: OFFSET1 and GAIN1 from COMP_1 01: OFFSET2 and GAIN2 from COMP_2 10: OFFSET3 and GAIN3 from COMP_3 11: OFFSET4 and GAIN4 from COMP_4
    $08 constant ADC_OFFSET_GAIN4               \ [0x08 : 2] OFFSET_GAIN4[1:0]: gain / offset used in ADC single positive mode with Vinput range = 2.4V: 00: OFFSET1 and GAIN1 from COMP_1 01: OFFSET2 and GAIN2 from COMP_2 10: OFFSET3 and GAIN3 from COMP_3 11: OFFSET4 and GAIN4 from COMP_4
    $0a constant ADC_OFFSET_GAIN5               \ [0x0a : 2] OFFSET_GAIN5[1:0]: gain / offset used in ADC differential mode with Vinput range = 2.4V: 00: OFFSET1 and GAIN1 from COMP_1 01: OFFSET2 and GAIN2 from COMP_2 10: OFFSET3 and GAIN3 from COMP_3 11: OFFSET4 and GAIN4 from COMP_4
    $0c constant ADC_OFFSET_GAIN6               \ [0x0c : 2] OFFSET_GAIN6[1:0]: gain / offset used in ADC single negative mode with Vinput range = 3.6V. This field also selects the gain/offset for VBAT input:: 00: OFFSET1 and GAIN1 from COMP_1 01: OFFSET2 and GAIN2 from COMP_2 10: OFFSET3 and GAIN3 from COMP_3 11: OFFSET4 and GAIN4 from COMP_4
    $0e constant ADC_OFFSET_GAIN7               \ [0x0e : 2] OFFSET_GAIN7[1:0]: gain / offset used in ADC single positive mode with Vinput range = 3.6V: 00: OFFSET1 and GAIN1 from COMP_1 01: OFFSET2 and GAIN2 from COMP_2 10: OFFSET3 and GAIN3 from COMP_3 11: OFFSET4 and GAIN4 from COMP_4
    $10 constant ADC_OFFSET_GAIN8               \ [0x10 : 2] OFFSET_GAIN8[1:0]: gain / offset used in ADC differential mode with Vinput range = 3.6V: 00: OFFSET1 and GAIN1 from COMP_1 01: OFFSET2 and GAIN2 from COMP_2 10: OFFSET3 and GAIN3 from COMP_3 11: OFFSET4 and GAIN4 from COMP_4
  [then]


  [ifdef] ADC_WD_TH_DEF
    \
    \ @brief WD_TH register
    \ Address offset: 0x3C
    \ Reset value: 0x0FFF0000
    \
    $00 constant ADC_WD_LT                      \ [0x00 : 12] WD_LT[11:0]: analog watchdog low level threshold.
    $10 constant ADC_WD_HT                      \ [0x10 : 12] WD_HT[11:0]: analog watchdog high level threshold.
  [then]


  [ifdef] ADC_WD_CONF_DEF
    \
    \ @brief WD_CONF register
    \ Address offset: 0x40
    \ Reset value: 0x00000000
    \
    $00 constant ADC_AWD_CHX                    \ [0x00 : 16] AWD_CHX[15:0]: analog watchdog channel selection to define which input channel(s) need to be guarded by the watchdog. Bit0: VINM[0] to ADC negative input Bit1: VINM[1] to ADC negative input Bit2: VINM[2] to ADC negative input Bit3: VINM[3] to ADC negative input Bit4: Not used Bit5: VBAT to ADC negative input Bit6: GND to ADC negative input Bit7: VDDA to ADC negative input Bit8: VINP[0] to ADC positive input Bit9: VINP[1] to ADC positive input Bit10: VINP[2] to ADC positive input Bit11: VINP[3] to ADC positive input Bit12: Not used Bit13: TEMP to ADC positive input Bit14: GND to ADC positive input Bit15: VDDA to ADC positive input
  [then]


  [ifdef] ADC_DS_DATAOUT_DEF
    \
    \ @brief DS_DATAOUT register
    \ Address offset: 0x44
    \ Reset value: 0x00000000
    \
    $00 constant ADC_DS_DATA                    \ [0x00 : 16] DS_DATA[15:0]: contain the converted data at the output of the Down Sampler.
  [then]


  [ifdef] ADC_IRQ_STATUS_DEF
    \
    \ @brief IRQ_STATUS register
    \ Address offset: 0x4C
    \ Reset value: 0x00000000
    \
    $00 constant ADC_EOC_IRQ                    \ [0x00] EOC_IRQ (Used in test mode only): set when the ADC conversion is completed. When read, provide the status of the interrupt: 0: ADC conversion is not completed 1: ADC conversion is completed Writing this bit clears the status of the interrupt: 0: no effect 1: clear the interrupt
    $01 constant ADC_EODS_IRQ                   \ [0x01] EODS_IRQ: set when the Down Sampler conversion is completed. When read, provide the status of the interrupt: 0: Down Sampler conversion is not completed 1: Down Sampler conversion is completed Writing this bit clears the status of the interrupt: 0: no effect 1: clear the interrupt
    $03 constant ADC_EOS_IRQ                    \ [0x03] EOS_IRQ: set when a sequence of conversion is completed. When read, provide the status of the interrupt: 0: sequence of conversion is not completed 1: sequence of conversion is completed Writing this bit clears the status of the interrupt: 0: no effect 1: clear the interrupt
    $04 constant ADC_AWD_IRQ                    \ [0x04] AWD_IRQ: set when an analog watchdog event occurs. When read, provide the status of the interrupt: 0: no analog watchdog event occurred 1: analog watchdog event has occurred Writing this bit clears the status of the interrupt: 0: no effect 1: clear the interrupt
    $05 constant ADC_OVR_DS_IRQ                 \ [0x05] OVR_DS_IRQ: set to indicate a Down Sampler overrun (at least one data is lost) When read, provide the status of the interrupt: 0: no overrun occurred 1: overrun occurred Writing this bit clears the status of the interrupt: 0: no effect 1: clear the interrupt
  [then]


  [ifdef] ADC_IRQ_ENABLE_DEF
    \
    \ @brief IRQ_ENABLE register
    \ Address offset: 0x50
    \ Reset value: 0x00000000
    \
    $00 constant ADC_EOC_IRQ                    \ [0x00] EOC_IRQ (Used in test mode only): set when the ADC conversion is completed. When read, provide the status of the interrupt: 0: ADC conversion is not completed 1: ADC conversion is completed Writing this bit clears the status of the interrupt: 0: no effect 1: clear the interrupt
    $01 constant ADC_EODS_IRQ                   \ [0x01] EODS_IRQ: set when the Down Sampler conversion is completed. When read, provide the status of the interrupt: 0: Down Sampler conversion is not completed 1: Down Sampler conversion is completed Writing this bit clears the status of the interrupt: 0: no effect 1: clear the interrupt
    $03 constant ADC_EOS_IRQ                    \ [0x03] EOS_IRQ: set when a sequence of conversion is completed. When read, provide the status of the interrupt: 0: sequence of conversion is not completed 1: sequence of conversion is completed Writing this bit clears the status of the interrupt: 0: no effect 1: clear the interrupt
    $04 constant ADC_AWD_IRQ                    \ [0x04] AWD_IRQ: set when an analog watchdog event occurs. When read, provide the status of the interrupt: 0: no analog watchdog event occurred 1: analog watchdog event has occurred Writing this bit clears the status of the interrupt: 0: no effect 1: clear the interrupt
    $05 constant ADC_OVR_DS_IRQ                 \ [0x05] OVR_DS_IRQ: set to indicate a Down Sampler overrun (at least one data is lost) When read, provide the status of the interrupt: 0: no overrun occurred 1: overrun occurred Writing this bit clears the status of the interrupt: 0: no effect 1: clear the interrupt
  [then]


  [ifdef] ADC_TEST_CONF_DEF
    \
    \ @brief TEST_CONF register
    \ Address offset: 0x60
    \ Reset value: 0x00000000
    \
    $00 constant ADC_ADC_SWITCH_EN              \ [0x00 : 16] ADC_SWITCH_EN[15:0]: enable individually each connection of the switching matrix at the ADC input. For each bit: 0: switch X is ON 1: switch X is OFF Bit mapping (corresponding to AUXADC_INSEL_1V2[15:0]): Bit 0: VINM[0] to ADC negative input Bit 1: VINM[1] to ADC negative input Bit 2: VINM[2] to ADC negative input Bit 3: VINM[3] to ADC negative input Bit4: GND to ADC negative input Bit5: VBAT to ADC negative input Bit6: GND to ADC negative input Bit7: VDDA to ADC negative input Bit8: VINP[0] to ADC positive input Bit9: VINP[1] to ADC positive input Bit10: VINP[2] to ADC positive input Bit11: VINP[3] to ADC positive input Bit12: VBAT to ADC positive input Bit13: TEMP to ADC positive input Bit14: GND to ADC positive input Bit15: VDDA to ADC positive input.
    $12 constant ADC_SEL_VIN_TYPE               \ [0x12 : 2] SEL_VIN_TYPE[1:0]: operation mode of the selected VIN 00: ADC single negative input 01: ADC single positive input 10: ADC differential input mode 11: reserved
    $15 constant ADC_ADC_RUN                    \ [0x15] ADC_RUN: Start/stop ADC conversion. 0: stop the ADC conversion, 1: starts the ADC conversion.
    $16 constant ADC_ADC_ENABLE                 \ [0x16] ADC_ENABLE: 0: disable the ADC (power OFF) 1: enable the ADC (power ON)
  [then]


  [ifdef] ADC_DTB_CONF_DEF
    \
    \ @brief DTB_CONF register
    \ Address offset: 0x64
    \ Reset value: 0x    NULL
    \
    $00 constant ADC_ADC_DBG_CONF               \ [0x00 : 4] ADC_DBG_CONF[3:0]: use for debug purpose.
    $08 constant ADC_ADC_DTB_CONF               \ [0x08 : 2] ADC_DTB_CONF[1:0]: configure the DTB output. 00: DTB bus is all 0 01: output the ADC_BUSY, ADC_EOC, offset compensation data[11:0] on the ADC_DTB 10: output the DS information on the ADC_DTB 11: select states of the FSM and enable ADC serial output Note: detailed DTB configurations are available in the Table 38 in IUM
    $0a constant ADC_DTB_SER_SEL                \ [0x0a] DTB_SER_SEL: DTB serial output selection when ADC_DB_CONF[1:0]=3d 0: pre down-sampler with offset compensation data 1: post down-sampler data
    $10 constant ADC_FSM_STATE                  \ [0x10 : 8] FSM_STATE[7:0]: show the state of the state machine. Bit 0: IDLE Bit 1: Reserved Bit 2: ADC setup phase Bit 3: Reserved Bit 4: ADC_START_CONV resynchronization Bit 5: Reserved Bit 6: ADC mode Bit 7: sequence mode
    $18 constant ADC_FSM_CUR_STATE              \ [0x18 : 3] FSM_CUR_STATE[2:0]: show the last executed state by the state machine. 000: IDLE mode 001: Reserved 010: ADC setup phase 011: Reserved 100: ADC_START_CONV resynchronization 101: Reserved 110: ADC mode 111: sequence mode
  [then]

  \
  \ @brief ADC address block description
  \
  $00 constant ADC_VERSION_ID           \ VERSION_ID register
  $04 constant ADC_CONF                 \ CONF register
  $08 constant ADC_CTRL                 \ CTRL register
  $14 constant ADC_SWITCH               \ SWITCH register
  $1C constant ADC_DS_CONF              \ DS_CONF register
  $20 constant ADC_SEQ_1                \ SEQ_1 register
  $24 constant ADC_SEQ_2                \ SEQ_2 register
  $28 constant ADC_COMP_1               \ COMP_1 register
  $2C constant ADC_COMP_2               \ COMP_2 register
  $30 constant ADC_COMP_3               \ COMP_3 register
  $34 constant ADC_COMP_4               \ COMP_4 register
  $38 constant ADC_COMP_SEL             \ COMP_SEL register
  $3C constant ADC_WD_TH                \ WD_TH register
  $40 constant ADC_WD_CONF              \ WD_CONF register
  $44 constant ADC_DS_DATAOUT           \ DS_DATAOUT register
  $4C constant ADC_IRQ_STATUS           \ IRQ_STATUS register
  $50 constant ADC_IRQ_ENABLE           \ IRQ_ENABLE register
  $60 constant ADC_TEST_CONF            \ TEST_CONF register
  $64 constant ADC_DTB_CONF             \ DTB_CONF register

: ADC_DEF ; [then]
